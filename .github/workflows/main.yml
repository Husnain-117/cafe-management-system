name: Cafe Management System Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ${{ github.repository_owner }}

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    permissions:
      contents: write  # Required for fallback upload
      packages: write
      actions: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Install required tools
        run: |
          sudo apt-get update
          sudo apt-get install -y curl zip unzip
          curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
          echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
          sudo apt update
          sudo apt install gh -y

      - name: Convert repository owner to lowercase
        run: |
          echo "OWNER_LC=${IMAGE_PREFIX,,}" >> $GITHUB_ENV
          echo "Using lowercase owner: ${{ env.OWNER_LC }}"

      # Build each service with proper error handling
      - name: Build Services
        run: |
          # Function to build a service
          build_service() {
            local service=$1
            local path=$2
            echo "Building $service from $path..."
            if [ ! -d "$path" ]; then
              echo "Directory $path does not exist!"
              exit 1
            fi
            docker build -t ${{ env.REGISTRY }}/${{ env.OWNER_LC }}/$service:latest $path || {
              echo "Failed to build $service"
              exit 1
            }
          }

          # Build all services
          build_service "api-gateway" "./api-gateway"
          build_service "menu-service" "./menu-services"
          build_service "order-service" "./order-services"
          build_service "payment-service" "./payment-services"
          build_service "inventory-service" "./inventory-services"
          build_service "customer-service" "./customer-services"

      - name: List built images
        run: |
          echo "Listing all built Docker images:"
          docker images | grep "${{ env.REGISTRY }}/${{ env.OWNER_LC }}" || true

      # Start services and test with proper error handling
      - name: Start and test services
        run: |
          echo "Starting services..."
          docker compose up -d || {
            echo "Failed to start services"
            docker compose logs
            exit 1
          }
          
          echo "Waiting for services to start..."
          sleep 45  # Increased wait time

          # Function to test a service
          test_service() {
            local service=$1
            local port=$2
            echo "Testing $service on port $port..."
            for i in {1..3}; do
              if curl -f http://localhost:$port/health; then
                echo "$service is healthy"
                return 0
              fi
              echo "Attempt $i failed, retrying in 10s..."
              sleep 10
            done
            echo "Failed to test $service after 3 attempts"
            return 1
          }

          # Test all services
          test_service "API Gateway" "3000"
          test_service "Menu Service" "3001"
          test_service "Order Service" "3002"
          test_service "Payment Service" "3003"
          test_service "Inventory Service" "3004"
          test_service "Customer Service" "3005"

      # Push images if on main branch
      - name: Push images
        if: github.ref == 'refs/heads/main'
        run: |
          # Function to push a service
          push_service() {
            local service=$1
            echo "Pushing $service..."
            docker push ${{ env.REGISTRY }}/${{ env.OWNER_LC }}/$service:latest || {
              echo "Failed to push $service"
              exit 1
            }
          }

          # Push all services
          push_service "api-gateway"
          push_service "menu-service"
          push_service "order-service"
          push_service "payment-service"
          push_service "inventory-service"
          push_service "customer-service"

      # Collect logs and create artifacts
      - name: Collect logs
        if: always()
        run: |
          # Create logs directory
          mkdir -p logs
          
          # Save Docker logs
          echo "=== Docker Compose Logs ===" > logs/docker.log
          docker compose logs --no-color > logs/docker.log 2>&1
          
          # Save Docker images info
          echo "=== Docker Images ===" > logs/images.log
          docker images > logs/images.log 2>&1
          
          # Save system info
          echo "=== System Info ===" > logs/system.log
          uname -a > logs/system.log 2>&1
          df -h >> logs/system.log 2>&1
          
          # Save service status
          echo "=== Service Status ===" > logs/status.log
          docker compose ps > logs/status.log 2>&1

          # Create a summary file
          {
            echo "# Workflow Run Summary"
            echo "## Build Information"
            echo "- Run ID: ${{ github.run_id }}"
            echo "- Run Number: ${{ github.run_number }}"
            echo "- Workflow: ${{ github.workflow }}"
            echo "- Repository: ${{ github.repository }}"
            echo "- Branch: ${{ github.ref }}"
            echo "- Commit: ${{ github.sha }}"
          } > logs/summary.md

          # Create ZIP archive
          zip -r workflow-logs.zip logs/

      # Try primary upload method
      - name: Upload artifacts (Primary)
        id: upload-primary
        continue-on-error: true
        uses: actions/upload-artifact@5d5d22a31266ced268874388b861e4b58bb5c2f3  # v3.1.2
        with:
          name: workflow-logs
          path: logs/
          retention-days: 5

      # Fallback to v2 if v3 fails
      - name: Upload artifacts (Fallback v2)
        if: steps.upload-primary.outcome == 'failure'
        id: upload-fallback-v2
        continue-on-error: true
        uses: actions/upload-artifact@v2
        with:
          name: workflow-logs
          path: logs/

      # Final fallback using GitHub CLI
      - name: Upload artifacts (Final Fallback)
        if: steps.upload-primary.outcome == 'failure' && steps.upload-fallback-v2.outcome == 'failure'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Create a release if we're on main branch
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            TAG_NAME="workflow-${GITHUB_RUN_ID}"
            gh release create $TAG_NAME workflow-logs.zip \
              --title "Workflow Run ${GITHUB_RUN_NUMBER} Artifacts" \
              --notes "Artifacts from workflow run ${GITHUB_RUN_NUMBER}"
          else
            echo "Not uploading artifacts via release as this is not the main branch"
          fi

      # Clean up
      - name: Cleanup
        if: always()
        run: |
          echo "Cleaning up..."
          docker compose down
          docker system prune -f 